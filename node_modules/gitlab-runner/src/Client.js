'use strict';

const util = require('util')
    , fs = require('fs')
    , markers = require('./markers')
    , Promise = require('bluebird')
    , readFile = Promise.promisify(fs.readFile)
    , EventEmitter = require('events').EventEmitter
    , WebSocket = require('ws')
    , runner = {}

util.inherits(Client, EventEmitter)

function Client(serverAddress, opt_socketFactory) {
  if (typeof serverAddress != 'string') {
    throw new TypeError('server address must be a string')
  }

  if (['undefined', 'function'].indexOf(typeof opt_socketFactory) == -1) {
    throw new TypeError('opt_socketFactory must be undefined or a function')
  }

  const self = this
      , server = serverAddress
      , socketFactory = opt_socketFactory || createSocket

  let socket = null
    , showLogs = false

  function getSocket() {
    if (!socket) {
      socket = socketFactory(server)
      socket.on('open', self.emit.bind(self, 'open'))
      socket.on('error', self.emit.bind(self, 'error'))
      socket.on('close', self.emit.bind(self, 'close'))
    }
    return socket
  }

  self.verbose = function (verbose) {
    showLogs = !!verbose
  }

  self.runFile = function (filename, opt_workingDirectory, opt_outputProcessor) {
    return new Promise((resolve, reject) => {
      const socket = getSocket()
      socket.on('open', function() {
        let promise = Promise.resolve()
        if (opt_workingDirectory) {
          promise = run(socket, 'cd ' + opt_workingDirectory, opt_outputProcessor)
        }

        promise
          .then(readFile.bind(null, filename, 'utf8'))
          .then(file => file.split('\n').filter(command => command && command.trim().length > 0))
          .then(commands => {
            let current = 0
            function next() {
              if (current >= commands.length) {
                return resolve()
              }
              const command = commands[current]
              current++
              run(socket, command, opt_outputProcessor)
                .then(next)
                .catch(reject)
            }
            next()
          })
          .catch(reject)
        })
    })
  }

  self.runCommand = function (command, opt_workingDirectory, opt_outputProcessor) {
    return new Promise((resolve, reject) => {
      const socket = getSocket()
      socket.on('open', function() {
        let promise = Promise.resolve()
        if (opt_workingDirectory) {
          promise = run(socket, 'cd ' + opt_workingDirectory, opt_outputProcessor)
        }

        promise
          .then(run.bind(null, socket, command, opt_outputProcessor))
          .then(resolve)
          .catch(reject)
      })
    })
  }

  function run(socket, command, opt_outputProcessor) {
    return new Promise((resolve, reject) => {
      socket.on('error', reject)
      socket.on('message', onMessage)
      socket.send(command, {}, () => {
        if (showLogs) {
          console.log(`   -> sent '${command}'`)
        }
        socket.removeListener('error', reject)
      })

      function onMessage(message) {
        if (showLogs) {
          console.log(`   <- rcv '${message}'`)
        }
        if (message.indexOf(markers.ERROR) == 0) {
          let error = message.substring(markers.ERROR.length)
          if (error.indexOf(markers.CODE) == 0) {
            const code = error.substring(markers.CODE.length)
            error = 'exit code: ' + code
          }
          socket.removeListener('message', onMessage)
          reject(error)
        } else if (message.indexOf(markers.DATA) == 0) {
          const data = message.substring(markers.DATA.length)
          if (data == markers.END) {
            socket.removeListener('message', onMessage)
            resolve()
          } else {
            opt_outputProcessor && opt_outputProcessor(data)
          }
        }
      }
    })
  }
}

function createSocket(server) {
  return new WebSocket('ws://' + server)
}

module.exports = Client
